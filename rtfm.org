#+TITLE: rtfm.el
#+AUTHOR: Yilkal Argaw , StackOverflow, Github, Emacs-wiki and The Internet in General
#+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
# #+HTML_HEAD: <link rel="stylesheet" href="https://classless.de/classless.css">
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://a-dma.github.io/gruvbox-css/gruvbox-dark-medium.min.
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sakura.css/css/sakura.css" type="text/css">
# #+HTML_HEAD: <link rel="stylesheet" href="https://unpkg.com/mvp.css"> 
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/holiday.css@0.11.2" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsDeliver.net/npm/@exampledev/new.css/new.min.css" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://unpkg.com/missing.css/dist/missing.min.css" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsDeliver.net/gh/yegor256/tacit@gh-pages/tacit-css.min.css" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://unpkg.com/boltcss/bolt.min.css" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/alvaromontoro/almond.css@latest/dist/almond.min.css" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/alvaromontoro/almond.css@latest/dist/almond.lite.min.css" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://unpkg.com/neobrutalismcss@latest" />
# #+HTML_HEAD: <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/eobrain/classless-tufte-css@v1.0.1/tufte.min.css"/>
# #+HTML_HEAD: <link rel="stylesheet" href="https://unpkg.com/latex.css/style.min.css" />
# #+HTML_HEAD: <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></scrip

#+INFOJS_OPT: view:overview toc:3 ltoc:3 mouse:underline buttons:0 path:https://orgmode.org/worg/code/org-info-js/org-info-src.js
#+OPTIONS: ^:nil
#+OPTIONS: _:nil
#+EXCLUDE_TAGS: noexport
#+PROPERTY: header-args :tangle (expand-file-name "compiled/rtfm.el" user-emacs-directory)

* beginning commentary
#+begin_src emacs-lisp
  ;;; early-init.el --- Early initialization. -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;
  ;; Emacs HEAD (27+) introduces early-init.el, which is run before init.el,
  ;; before package and UI initialization happens.
  ;;

  ;;; Code:

#+end_src


* vanilla emacs settings
  
** mostly related to initialization process

*** earlyinits

This snippet ensures that users running versions of Emacs prior to
27.0 can utilize custom configurations defined in early-init.el,
thereby enhancing their Emacs experience without disrupting
compatibility with newer versions.

#+begin_src emacs-lisp

  (when (version< emacs-version "27.0")
    (let ((dafile
           (expand-file-name "early-init.el" user-emacs-directory)))
      (when (file-exists-p dafile)
        (load-file dafile))))

#+end_src

*** other init settings for speed

Inhibit the default setting and kill scratch buffer to speedup
initialization time and I don't like having an elisp interaction mode
as the default scratch buffer.

#+begin_src emacs-lisp

  (customize-set-variable 'inhibit-default-init t)
  ;; (setq initial-major-mode 'fundamental-mode)
  (kill-buffer "*scratch*")

#+end_src

*** suppress some ad-handle-definition warnings

Accept ad-redefinitions during advice redefintions. I want it to
accept it to avoid warnings related to them. Original value was
‘warn’.

#+begin_src emacs-lisp

  (customize-set-variable 'ad-redefinition-action 'accept)

#+end_src

*** more garbage collection related settings

Define functions to change gc-cons-threshold to the maximum fixnum so
that garbage collection could be defered. This part delays garbage
collection during minibuffer completions to until when you exit the
minibuffer.

#+begin_src emacs-lisp

  (defvar rtfm-emacs-gc-cons-threshold (* 32 1024 1024))

  (defun rtfm-emacs-defer-garbage-collection-h ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun rtfm-emacs-restore-garbage-collection-h ()
    ;; Defer it so that commands launched immediately after will enjoy the
    ;; benefits.
    (run-at-time
     1 nil (lambda () (setq gc-cons-threshold (* 32 1024 1024)))))

  (add-hook 'minibuffer-setup-hook #'rtfm-emacs-defer-garbage-collection-h)
  (add-hook 'minibuffer-exit-hook #'rtfm-emacs-restore-garbage-collection-h)

#+end_src


** some constants and settings that need to be configured initially

*** COMMENT constants

Dynamically generate version-specific constants for Emacs versions 24
through 35 and defines constants to identify the operating system
type. This allows for easy conditional checks based on both Emacs
version and the underlying system, facilitating cross-platform
compatibility in configurations.

#+begin_src emacs-lisp

  ;; define  variables by using a macro that generates and evaluates as below
  ;; (defconst EMACS24+   (> emacs-major-version 23)) using macros
  (defmacro rtfm-emacs-gen-ver-consts (var)
    "Define a macro to create constants to check Emacs version greater than VAR."
    (list 'defconst
          (intern (concat "EMACS" (int-to-string var) "+"))
          (> emacs-major-version (- var 1))))

  ;;evaluate the macro for the number range we want
  (seq-do (lambda (x) (eval (list 'rtfm-emacs-gen-ver-consts x))) (number-sequence 24 35))

  ;; (map #(eval (list 'rtfm-emacs-gen-ver-consts %)) (range 24 36))

  (defconst IS-MAC     (eq system-type 'darwin))
  (defconst IS-LINUX   (eq system-type 'gnu/linux))
  (defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
  (defconst IS-BSD     (or IS-MAC (eq system-type 'berkeley-unix)))

#+end_src

*** custom-file settings

Direct Emacs to save custom settings in a specific file (custom.el),
which helps in organizing user configurations and maintaining them
separately from the main configuration file.

#+begin_src emacs-lisp

  (customize-set-variable
   'custom-file
   (expand-file-name "custom.el" user-emacs-directory))

  ;; (add-hook 'kill-emacs-query-functions
  ;;           'custom-prompt-customize-unsaved-options)

#+end_src

*** gnutls and security

#+begin_src emacs-lisp

  ;;; Security

  ;; Emacs is essentially one huge security vulnerability, what with all the
  ;; dependencies it pulls in from all corners of the globe. Let's try to be at
  ;; least a little more discerning.
  (with-no-warnings

    (setq gnutls-verify-error (not (getenv-internal "INSECURE"))
          gnutls-algorithm-priority
          (when (boundp 'libgnutls-version)
            (concat "SECURE128:+SECURE192:-VERS-ALL"
                    (if (and (not IS-WINDOWS)
                             (not (version< emacs-version "26.3"))
                             (>= libgnutls-version 30605))
                        ":+VERS-TLS1.3")
                    ":+VERS-TLS1.2"))
          ;; `gnutls-min-prime-bits' is set based on recommendations from
          ;; https://www.keylength.com/en/4/
          gnutls-min-prime-bits 3072
          tls-checktrust gnutls-verify-error
          ;; Emacs is built with `gnutls' by default, so `tls-program' would not be
          ;; used in that case. Otherwise, people have reasons to not go with
          ;; `gnutls', we use `openssl' instead. For more details, see
          ;; https://redd.it/8sykl1
          tls-program '("openssl s_client -connect %h:%p -CAfile %t -nbio -no_ssl3 -no_tls1 -no_tls1_1 -ign_eof"
                        "gnutls-cli -p %p --dh-bits=3072 --ocsp --x509cafile=%t \
  --strict-tofu --priority='SECURE192:+SECURE128:-VERS-ALL:+VERS-TLS1.2:+VERS-TLS1.3' %h"
                        ;; compatibility fallbacks
                        "gnutls-cli -p %p %h"))

    ;; Emacs stores `authinfo' in $HOME and in plain-text. Let's not do that, mkay?
    ;; This file stores usernames, passwords, and other such treasures for the
    ;; aspiring malicious third party.
    (setq auth-sources (list (expand-file-name "authinfo.gpg"  user-emacs-directory)
                             "~/.authinfo.gpg")))

  ;;gnutls
  (add-hook 'after-init-time-hook (setq gnutls-min-prime-bits 4096))

#+end_src

*** encryption related additional

Select gpg2 for the gpg version to use and specify authinfo.gpg for
credentials.

#+begin_src emacs-lisp

  ;; (customize-set-variable 'epg-gpg-program "gpg2")
  (customize-set-variable 'auth-sources '("~/.authinfo.gpg"))

#+end_src

*** lexical binding

Lexical binding is a feature in Emacs Lisp (Elisp) that allows
variables to be bound within the scope where they are defined, rather
than dynamically through the call stack. This mechanism significantly
influences how variables behave and are accessed in Elisp, leading to
more predictable and intuitive programming.

#+begin_src emacs-lisp

  (setq-default lexical-binding t)

#+end_src




** window(frame) look and feel setting
*** minor modes menu much like minions

#+begin_src emacs-lisp

  (defun rtfm-emacs-minions--modes ()
    (let (local global)
      (dolist (entry minor-mode-alist)
        (let ((mode (car entry)))
          (when (and (boundp mode)
                     (symbol-value mode))
            (when (local-variable-if-set-p mode)
              (push mode local)
              (push mode global)))))
      (list (sort local  #'string<)
            (sort global #'string<))))

  (defun rtfm-emacs-minions-minor-modes-menu ()
    (interactive)
    (let ((map (make-sparse-keymap))
          local global)
      (let ((modes (rtfm-emacs-minions--modes)))
        (setq local (nth 0 modes))
        (setq global (nth 1 modes)))
      (define-key-after map [--local] (list 'menu-item "Local Modes"))
      (dolist (mode local)
        (let ((menu (and (symbol-value mode)
                         (rtfm-emacs-minions--mode-menu mode))))
          (if menu
              (define-key-after map (vector mode) menu)
            (rtfm-emacs-minions--define-toggle map mode))))
      (define-key-after map [--line2]  (list 'menu-item "--double-line"))
      (define-key-after map [--global] (list 'menu-item "Global Modes"))
      (dolist (mode global)
        (let ((menu (and (symbol-value mode)
                         (rtfm-emacs-minions--mode-menu mode))))
          (if menu
              (define-key-after map (vector mode) menu)
            (rtfm-emacs-minions--define-toggle map mode))))
      (define-key-after map [--line1] (list 'menu-item "--double-line"))
      (define-key-after map [describe-mode]
        (list 'menu-item "Describe modes" 'describe-mode))
      (condition-case nil
          (popup-menu map)
        (quit nil))))

  (defun rtfm-emacs-minions--mode-menu (mode)
    (let* ((map  (or (cdr (assq mode minor-mode-map-alist))
                     (cdr (assq mode minor-mode-overriding-map-alist))))
           (menu (and (keymapp map)
                      (lookup-key map [menu-bar])))
           (menu (and menu
                      (mouse-menu-non-singleton menu))))
      (and menu
           (let ((wrap (make-sparse-keymap)))
             (set-keymap-parent wrap menu)
             (rtfm-emacs-minions--define-toggle wrap mode)
             (define-key-after wrap [rtfm-emacs-minions] (list 'menu-item "--double-line"))
             (list 'menu-item (symbol-name mode) wrap)))))

  (defun rtfm-emacs-minions--define-toggle (map mode)
    (let ((fn (or (get mode :minor-mode-function) mode)))
      (when (functionp fn)
        (define-key-after map (vector mode)
          (list 'menu-item (symbol-name mode) fn
                :button (cons :toggle mode))))))

#+end_src

*** modify mode-line

#+begin_src emacs-lisp

  (defun mode-line-split--format (left right)
    "Return a string of `window-width' length containing LEFT and
  RIGHT, aligned respectively."
    (let ((reserve (length right)))
      (concat left
              " "
              (propertize " "
                          'display `((space :align-to (- right (- 0 right-margin) ,reserve))))
              right)))

  ;; Set the new mode-line-format
  (if (display-graphic-p)
      (setq-default mode-line-format
                    '((:eval
                       (mode-line-split--format
                        ;; Left
                        (format-mode-line
                         '("%e" mode-line-front-space
                           (:propertize
                            ("" mode-line-mule-info mode-line-client mode-line-modified mode-line-remote)
                            display
                            (min-width
                             (5.0)))
                           mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position))
                        ;; Right
                        (format-mode-line
                         '((vc-mode vc-mode)
                           "   "
                           mode-name " ";; "%m"
                           (:eval (propertize "[+]" 'local-map (make-mode-line-mouse-map 'mouse-1 'rtfm-emacs-minions-minor-modes-menu)))
                           "   "
                           (:eval (propertize "[≡]" 'local-map (make-mode-line-mouse-map 'mouse-1 'menu-bar-open)))
                           " "
                           "  " mode-line-misc-info mode-line-end-spaces
                           )
                         )))))
    (setq-default mode-line-format
                  '((:eval
                     (mode-line-split--format
                      ;; Left
                      (format-mode-line
                       '("%e" mode-line-front-space
                         (:propertize
                          ("" mode-line-mule-info mode-line-client mode-line-modified mode-line-remote)
                          display
                          (min-width
                           (5.0)))
                         mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position))
                      ;; Right
                      (format-mode-line
                       '((vc-mode vc-mode)
                         "   "
                         mode-name " ";; "%m"
                         "  " mode-line-misc-info mode-line-end-spaces
                         )
                       ))))))

#+end_src

*** headerline

#+begin_src emacs-lisp

  (setq-default header-line-format '(:eval (substring ""
                                                      (min (length " ")
                                                           (window-hscroll)))))
#+end_src

*** disable dialogues

#+begin_src emacs-lisp

  (setq use-dialog-box nil)
  (setq use-file-dialog nil)

#+end_src

*** cursor type
#+begin_src emacs-lisp

  (setq-default cursor-type '(bar . 5))  ;; 'bar or 'box, 'hbar, etc.

#+end_src




** require some libraries

Require some libraries like cl-lib and color because they are
necessary for the rest of the config.

#+begin_src emacs-lisp

  (if EMACS26+ (require 'cl-lib)
    (require 'cl))

  (require 'color)

#+end_src


** set load path

#+begin_src emacs-lisp

  (defun add-subdirs-to-load-path (dir)
    "Add all directories under DIR to `load-path` if not already present."
    (dolist (subdir (directory-files dir t "^[^.]"))  ; Iterate over non-hidden files
      (when (file-directory-p subdir)                 ; Check if it's a directory
        (unless (member subdir load-path)              ; If not already in load-path
          (add-to-list 'load-path subdir))             ; Add it to load-path
        (add-subdirs-to-load-path subdir))))            ; Recursively call for subdirectories

  ;; Example usage: Add all subdirectories of the site-lisp directory to load-path
  (let ((lisp-dir (expand-file-name "site-lisp" user-emacs-directory)))
    (unless (file-directory-p lisp-dir)
      (make-directory lisp-dir))  ; Ensure the site-lisp directory exists
    (unless (member lisp-dir load-path)
      (add-to-list 'load-path lisp-dir))  ; Add the site-lisp directory to load-path
    (add-subdirs-to-load-path lisp-dir))  ; Add all subdirectories recursively

#+end_src


** basic emacs editor preferences
*** set utf-8 as default coding system

#+begin_src emacs-lisp

  (set-language-environment "UTF-8")
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+end_src

*** autorevert

#+begin_src emacs-lisp

  (add-hook 'after-init-hook  #'global-auto-revert-mode)

#+end_src

*** revert buffer on f5

#+begin_src emacs-lisp

  (defun rtfm-revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive)
    (revert-buffer :ignore-auto :noconfirm))

  (global-set-key (kbd "<f5>") #'rtfm-revert-buffer-no-confirm)

#+end_src

*** backup and auto-save-list

#+begin_src emacs-lisp

  ;;backups

  (let ((thedir  (expand-file-name "auto-save-list" user-emacs-directory)))
    (unless (file-directory-p thedir)
      (make-directory thedir)))

  (let ((thedir  (expand-file-name "backups" user-emacs-directory)))
    (unless (file-directory-p thedir)
      (make-directory thedir)))

  (setq ;; backup-directory-alist '(((expand-file-name "backups" user-emacs-directory)))
   backup-by-copying t    ; Don't delink hardlinks
   version-control t      ; Use version numbers on backups
   delete-old-versions t  ; Automatically delete excess backups
   kept-new-versions 20   ; how many of the newest versions to keep
   kept-old-versions 5    ; and how many of the old
   ;;auto-save-file-name-transforms `((expand-file-name "backups" user-emacs-directory) t)
   auto-save-file-name-transforms
   `((".*" ,(expand-file-name  "auto-save-list" user-emacs-directory) t))
   backup-directory-alist
   `((".*" . ,(expand-file-name  "backups" user-emacs-directory)))
   )

#+end_src

*** clipboard

#+begin_src emacs-lisp

  ;;clipboard

  (customize-set-variable 'select-enable-clipboard t)

#+end_src

*** yes,no

#+begin_src emacs-lisp

  ;;yes,no
  (fset 'yes-or-no-p 'y-or-n-p)

#+end_src

*** enable some disabled commands

#+begin_src emacs-lisp

  ;; enable narrowing commands
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)

  ;; enabled change region case commands
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)

#+end_src

*** indentation stuff

#+begin_src emacs-lisp

  ;; ;; to setup tabs
  ;; (setq c-basic-indent 2)
  ;; (setq tab-width 4)
  ;; (setq indent-tabs-mode nil)

  (defvaralias 'c-basic-offset 'tab-width)
  (defvaralias 'c-basic-indent 'tab-width)
  (defvaralias 'cperl-indent-level 'tab-width)
  (customize-set-variable 'indent-tabs-mode nil)
  (setq-default tab-width 4)

  ;; make tab key do indent first then completion.
  (setq-default tab-always-indent 'complete)

#+end_src

*** Sentences end with a single space

#+begin_src emacs-lisp

  (customize-set-variable 'sentence-end-double-space nil)

#+end_src

*** line-spacing

#+begin_src emacs-lisp

  (setq-default line-spacing 0.1)
  (add-hook 'minibuffer-setup-hook (lambda () (setq line-spacing nil)))

#+end_src

*** line-number

#+begin_src emacs-lisp

  ;;line-numbers

  (when EMACS26+
    (setq-default display-line-numbers-type 'relative
                  display-line-numbers-grow-only t
                  display-line-numbers-width-start t
                  display-line-numbers-width 4 )

    (global-display-line-numbers-mode t))

#+end_src

*** show-parens

#+begin_src emacs-lisp

  (customize-set-variable 'show-paren-mode t)

#+end_src

*** scrolling
**** horizontal scrolling

#+begin_src emacs-lisp

  (add-hook 'prog-mode-hook (lambda () (setq truncate-lines t)))
  (add-hook 'html-mode-hook (lambda () (setq truncate-lines t)))
  (add-hook 'web-mode-hook (lambda () (setq truncate-lines t)))
  (add-hook 'dired-mode-hook (lambda () (setq truncate-lines t)))
  (add-hook 'org-mode (lambda () (setq truncate-lines nil)))
  ;; (add-hook 'eww-after-render-hook (lambda () (setq truncate-lines t)))

  (customize-set-variable 'hscroll-margin 0)

  (global-set-key (kbd "<mouse-7>") #'(lambda ()
                                        (interactive)
                                        (scroll-left 4)))

  (global-set-key (kbd "<mouse-6>") #'(lambda ()
                                        (interactive)
                                        (scroll-right 4)))

#+end_src

**** smooth-scrolling

#+begin_src emacs-lisp
  ;; Make scrolling less stuttered
  (when EMACS29+
    (pixel-scroll-precision-mode t)
    (setq-default pixel-scroll-precision-large-scroll-height 40.0
                  pixel-scroll-precision-interpolation-factor 30))

  (customize-set-variable 'auto-window-vscroll nil)
  (customize-set-variable 'fast-but-imprecise-scrolling t)
  (customize-set-variable 'scroll-conservatively 101)
  (customize-set-variable 'scroll-margin 0)
  (customize-set-variable 'scroll-preserve-screen-position t)
  ;; (customize-set-variable 'mouse-wheel-progressive-speed t)

#+end_src

*** marking

#+begin_src emacs-lisp

  (transient-mark-mode 1)

  (delete-selection-mode 1)

  (defun push-mark-no-activate ()
    "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
    (interactive)
    (push-mark (point) t nil)
    (message "Pushed mark to ring"))

  (defun jump-to-mark ()
    "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
    (interactive)
    (set-mark-command 1))

  (defun exchange-point-and-mark-no-activate ()
    "Identical to \\[exchange-point-and-mark] but will not activate the region."
    (interactive)
    (exchange-point-and-mark)
    (deactivate-mark nil))

#+end_src

*** isearch

#+begin_src emacs-lisp

  (setq-default
   ;; Match count next to the minibuffer prompt
   isearch-lazy-count t
   ;; Don't be stingy with history; default is to keep just 16 entries
   search-ring-max 200
   regexp-search-ring-max 200)

  ;; swiper like fuzzy search
  ;; (setq-default
  ;;  isearch-regexp-lax-whitespace t
  ;;  search-whitespace-regexp ".*?")

  ;; (defun move-end-of-line-maybe-ending-isearch (arg)
  ;; "End search and move to end of line, but only if already at the end of the minibuffer."
  ;;   (interactive "p")
  ;;   (if (eobp)
  ;;       (isearch-mb--after-exit
  ;;        (lambda ()
  ;;          (move-end-of-line arg)
  ;;          (isearch-done)))
  ;;     (move-end-of-line arg)))

  ;; (define-key isearch-mb-minibuffer-map (kbd "C-e") 'move-end-of-line-maybe-ending-isearch)

#+end_src

*** explicitly set shell

#+begin_src emacs-lisp

  ;; (customize-set-variable 'explicit-shell-file-name "/bin/bash")

  (if (executable-find "bash")
      (customize-set-variable 'explicit-shell-file-name "/bin/bash")
    (customize-set-variable 'explicit-shell-file-name "/bin/sh"))

#+end_src

*** better support for long lines

#+begin_src emacs-lisp

  ;; Better support for files with long lines
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq-default bidi-inhibit-bpa t)
  (when EMACS27+
    (global-so-long-mode 1))

#+end_src

*** rectangle mode

#+begin_src emacs-lisp

  (require 'rect)
  (with-eval-after-load 'rect
    ;; (define-key rectangle-mark-mode-map (kbd "f") #'rectangle-right-char)
    ;; (define-key rectangle-mark-mode-map (kbd "b") #'rectangle-left-char)
    (define-key rectangle-mark-mode-map (kbd "n") #'rectangle-next-line)
    (define-key rectangle-mark-mode-map (kbd "p") #'rectangle-previous-line)
    (define-key rectangle-mark-mode-map (kbd "f") #'rectangle-forward-char)
    (define-key rectangle-mark-mode-map (kbd "b") #'rectangle-backward-char)
    (define-key rectangle-mark-mode-map (kbd "i") #'string-rectangle)
    (define-key rectangle-mark-mode-map (kbd "e") #'rectangle-exchange-point-and-mark)
    (define-key rectangle-mark-mode-map (kbd "#") #'rectangle-number-lines)
    (define-key rectangle-mark-mode-map (kbd "w") #'copy-rectangle-as-kill) ; C-x r M-w
    (define-key rectangle-mark-mode-map (kbd "y") #'yank-rectangle)         ; C-x r y
    (define-key rectangle-mark-mode-map (kbd "t") #'string-rectangle)     ; C-x r t
    (define-key rectangle-mark-mode-map (kbd "d") #'kill-rectangle)         ; C-x r d
    (define-key rectangle-mark-mode-map (kbd "c") #'clear-rectangle)       ; C-x r c
    (define-key rectangle-mark-mode-map (kbd "o") #'open-rectangle)        ; C-x r o
    (define-key rectangle-mark-mode-map (kbd "N") #'rectangle-number-lines)        ; C-x r N
    (define-key rectangle-mark-mode-map (kbd "e") #'rectangle-exchange-point-and-mark) ; C-x C-x
    (define-key rectangle-mark-mode-map (kbd "u") #'undo)
    )

#+end_src

*** highlight current line on big movements

#+begin_src emacs-lisp

  (defvar rtfm-emacs-position-highlight-overlay nil
    "Overlay used to highlight the current line.")

  (defun rtfm-emacs-position-highlight-highlight-line ()
    "Briefly highlight the current line."
    (when rtfm-emacs-position-highlight-overlay
      (delete-overlay rtfm-emacs-position-highlight-overlay))
    (let ((start (line-beginning-position))
          (end (line-end-position))
          (region-bg (face-attribute 'region :background)))  ; Get theme's region color
      (setq rtfm-emacs-position-highlight-overlay (make-overlay start end))
      (overlay-put rtfm-emacs-position-highlight-overlay 'face `(:background ,region-bg))  ; Use dynamic color
      (run-with-timer 0.15 nil #'delete-overlay rtfm-emacs-position-highlight-overlay)))


  (when EMACS28+
    (progn
      ;; Hook into window switching
      (add-hook 'window-selection-change-functions
                (lambda (_win) (rtfm-emacs-position-highlight-highlight-line)))

      ;; Hook into common scroll commands
      (dolist (cmd '(scroll-up-command
                     scroll-down-command
                     recenter-top-bottom
                     other-window
                     next-line
                     previous-line
                     end-of-buffer
                     beginning-of-buffer))
        (advice-add cmd :after (lambda (&rest _) (rtfm-emacs-position-highlight-highlight-line))))))

#+end_src

    
** theming

#+begin_src emacs-lisp

  (with-no-warnings
  
    (add-hook 'after-init-time-hook
              (progn
                (defadvice load-theme (after custom-faces-after-load-theme())
                  "Insert an empty line when moving up from the top line."
                  (let ((dafile (expand-file-name "custom_faces.el" user-emacs-directory)))
                    (when (file-exists-p dafile) (load-file dafile))
                    ;; (save-excursion
                    ;;  (if (and solaire-mode (fboundp 'dashboard-refresh-buffer)) (dashboard-refresh-buffer)))
                    ))


                (ad-activate 'load-theme)

                (defadvice disable-theme (after custom-faces-after-disable-theme())
                  "Insert an empty line when moving up from the top line."
                  (let ((dafile (expand-file-name "custom_faces.el" user-emacs-directory)))
                    (when (file-exists-p dafile) (load-file dafile))
                    ;; (save-excursion
                    ;;  (if (and solaire-mode (fboundp 'dashboard-refresh-buffer)) (dashboard-refresh-buffer)))
                    ))
                (ad-activate 'disable-theme)))

    (add-hook 'after-init-time-hook
              (let ((dafile (expand-file-name "custom_faces.el" user-emacs-directory)))
                (when (file-exists-p dafile) (load-file dafile)))))

#+end_src

   
** completion

#+begin_src emacs-lisp

(setq enable-recursive-minibuffers t)
(setq completion-cycle-threshold 1)
(setq tab-always-indent 'complete)
(setq completion-styles '(basic initials substring))
(setq completion-auto-help 'always)
(when EMACS28+ (setopt completions-detailed t))
(setq completion-auto-help 'lazy)                  ; Open completion `always'; `lazy' another option
(when EMACS28+ (setopt completions-format 'one-column))
(when EMACS28+ (setopt completions-group t))
(when EMACS29+ (setopt completion-auto-select 'second-tab))
(when EMACS29+ (setopt completions-max-height 20))

;; (keymap-set minibuffer-mode-map "TAB" 'minibuffer-complete)
(define-key minibuffer-local-map (kbd "TAB") 'minibuffer-complete)

(when (not EMACS26+) (ido-mode))
(when EMACS26+ (icomplete-mode))
(when EMACS27+ (fido-mode))
(when EMACS28+ (fido-vertical-mode))

#+end_src

   
** scratch_buffer_creator

#+begin_src emacs-lisp

(defun create-scratch-buffer (mode)
  "Create a new scratch buffer with a specified major MODE."
  (interactive
   (list (intern (completing-read "Choose major mode: "
                                   (mapcar 'symbol-name
                                           (apropos-internal "-mode$"))))))
  (let* ((buffer-name (generate-new-buffer-name "*scratch*"))
         (comment-start (if (fboundp mode)
                            (with-temp-buffer
                              (funcall mode)
                              (if (boundp 'comment-start)
                                  comment-start
                                ";; ")) ;; Fallback if no comment-start is defined
                          ";; ")))  ;; Fallback for invalid modes
    (generate-new-buffer buffer-name)
    (switch-to-buffer buffer-name)
    (funcall mode)  ;; Set the specified major mode
    (insert comment-start "This is a new scratch buffer in " 
            (symbol-name mode) " mode.\n\n")))

#+end_src

   
** emacs built in packages

*** imenu

#+begin_src emacs-lisp

(with-eval-after-load 'imenu (set-default 'imenu-auto-rescan t))

#+end_src

*** ibuffer

#+begin_src emacs-lisp

(global-set-key (kbd "C-x C-b") 'ibuffer)

#+end_src

*** comint-mode

#+begin_src emacs-lisp

;;conmint-mode
(with-eval-after-load 'comint
  (customize-set-variable 'comint-scroll-show-maximum-output nil)
  (customize-set-variable 'comint-scroll-to-bottom-on-input nil)
  (customize-set-variable 'comint-scroll-to-bottom-on-output nil)
  (add-hook 'comint-mode-hook (lambda () (when EMACS26+ (display-line-numbers-mode -1)))))

#+end_src

*** shell-mode

#+begin_src emacs-lisp

;;shell-mode

(require 'shell)
(with-eval-after-load 'shell
  (define-key shell-mode-map (kbd "<tab>") 'completion-at-point)
  (define-key shell-mode-map (kbd "<backtab>") 'completion-at-point)
  (add-hook 'comint-mode-hook (lambda () (when EMACS26+ (display-line-numbers-mode -1)))))

#+end_src

*** eshell

#+begin_src emacs-lisp

(require 'eshell)

(with-eval-after-load 'eshell

  (customize-set-variable 'eshell-visual-commands
                          '("vi" "screen" "top" "less" "more" "lynx"
                            "ncftp" "pine" "tin" "trn" "elm" "vim" "kak"
                            "nano" "tmux" "alpine" "mutt" "htop" "irb"
                            "python" "python3" "python2" "csc" "sbcl"
                            "guile" "guile2" "node" "joe" "jstar"
                            "jmacs" "jpico" "ne" "micro" "nnn" "lf"
                            "ranger" "mc" "gtypist" "toipe"))

  (add-hook 'eshell-mode-hook (lambda () (when EMACS26+ (display-line-numbers-mode -1))))

  (customize-set-variable 'eshell-scroll-show-maximum-output nil))

#+end_src

*** term-mode

#+begin_src emacs-lisp

(require 'term)
(with-eval-after-load 'term
  (define-key term-raw-map (kbd "C-c C-y") 'term-paste)
  (add-hook 'term-mode-hook (lambda () (when EMACS26+ (display-line-numbers-mode -1))))
  (add-hook 'term-mode-hook (lambda () (display-line-numbers-mode -1)))

  (defun term-just-close-exec-hook ()
    (let* ((buff (current-buffer))
           (proc (get-buffer-process buff)))
      (set-process-sentinel
       proc
       `(lambda (process event)
          (if (string= event "finished\n")
              (kill-buffer ,buff))))))

  (add-hook 'term-exec-hook 'term-just-close-exec-hook))

#+end_src

*** eww & shr

#+begin_src emacs-lisp

(add-hook 'eww-mode-hook (lambda () (when EMACS26+ (display-line-numbers-mode -1))))

#+end_src

*** ediff

#+begin_src emacs-lisp

(add-hook 'ediff-prepare-buffer-hook 'outline-show-all)
(add-hook 'ediff-quit-hook 'winner-undo)

(with-eval-after-load 'ediff
  (customize-set-variable 'ediff-window-setup-function 'ediff-setup-windows-plain)
  (customize-set-variable 'ediff-split-window-function 'split-window-horizontally)
  (customize-set-variable 'ediff-merge-split-window-function 'split-window-horizontally))

#+end_src

*** whitespace-mode

#+begin_src emacs-lisp

  (with-eval-after-load 'whitespace
    ;; Make whitespace-mode with very basic background coloring for whitespaces.
    ;; http://xahlee.info/emacs/emacs/whitespace-mode.html
    (customize-set-variable 'whitespace-style (quote (face spaces tabs newline space-mark tab-mark newline-mark )))

    ;; Make whitespace-mode and whitespace-newline-mode use “¶” for end of line char and “▷” for tab.
    (customize-set-variable 'whitespace-display-mappings
          ;; all numbers are unicode codepoint in decimal. e.g. (insert-char 182 1)
          '(
            (space-mark 32 [183] [46]) ; SPACE 32 「 」, 183 MIDDLE DOT 「·」, 46 FULL STOP 「.」
            ;; (space-mark 32 [168] [46]) ; SPACE 32 「 」, 183 MIDDLE DOT 「·」, 46 FULL STOP 「.」
            (newline-mark 10 [182 10]) ; LINE FEED,
            ;; (newline-mark 10 [36 10]) ; LINE FEED,
            ;; (newline-mark 10 [172 10]) ; LINE FEED
            (tab-mark 9 [9655 9] [92 9]) ; tab
            ))

  ;; Don't enable whitespace for.
  (setq-default whitespace-global-modes
                '(not shell-mode
                      eshell-mode
                      term-mode
                      comint-mode
                      vterm-mode
                      help-mode
                      magit-mode
                      magit-diff-mode
                      ibuffer-mode
                      dired-mode
                      occur-mode
                      org-mode
                      pdf-view-mode
                      nov-mode
                      artist-mode
                      text-mode
                      fundamental-mode)))

  (add-hook 'artist-mode-hook (lambda () (whitespace-mode -1)))

  (let* ((color-cells (display-color-cells)))
    (when (or
           (display-graphic-p)
           (> color-cells 256))
      (add-hook 'after-init-hook (global-whitespace-mode t))))

#+end_src

*** recentf

#+begin_src emacs-lisp

;; Turn on recentf mode
(add-hook 'after-init-hook #'recentf-mode)
(customize-set-variable 'recentf-save-file
                        (expand-file-name "recentf" user-emacs-directory))

#+end_src

*** hippie_expand

#+begin_src emacs-lisp

(global-set-key [remap dabbrev-expand] 'hippie-expand)

#+end_src

*** abbrev

#+begin_src emacs-lisp

(setq-default abbrev-file-name (expand-file-name "abbrev_defs"  user-emacs-directory))
(if (file-exists-p abbrev-file-name)
    (quietly-read-abbrev-file)
  (setq save-abbrevs 'silently))

(require 'abbrev)

#+end_src

*** tempo

This file provides a simple way to define powerful templates, or
macros, if you wish. It is mainly intended for, but not limited to,
other programmers to be used for creating shortcuts for editing
certain kind of documents. Most of what I learned about this package
from the following the article on
https://www.lysator.liu.se/~davidk/elisp/tempo-examples.html by the
Author(or I think it is the author)

The settings in the "general settings" part are used to override
"space" so that tempo completion could take place after writing a
valid tag and define a keymap for the package. Movement keys are set
to "C-c t f", and "C-c t b" for moving forward and moving backward
respectively inside the stops in the snippet.

**** general settings needed for snippets

sourced from https://www.lysator.liu.se/~davidk/elisp/tempo-examples.html

#+begin_src emacs-lisp

(require 'tempo)

(defvar tempo-map nil "Prefix map for Tempo key bindings.")

(defun tempo-space ()
  ""
  (interactive)
  (if (tempo-expand-if-complete)
      nil
    (insert " ")))

(defun try-expand-tempo-tag (old)
  "Try to expand a Tempo tag."
  (unless old
    (tempo-complete-tag)))

(defun set-tempo ()
  "Set up emacs-lisp mode to use tempo.el"
  (require 'tempo)  ;; Ensure tempo.el is loaded
  (unless tempo-map  ;; Only define it if it's not already defined
    (define-prefix-command 'tempo-map))  ;; Define the tempo-map globally
  (local-set-key (kbd "C-c t") 'tempo-map)  ;; Bind the prefix to C-c t
  (define-key tempo-map (kbd "c") 'tempo-complete-tag)  ;; Define keybindings
  (define-key tempo-map (kbd "n") 'tempo-forward-mark)
  (define-key tempo-map (kbd "p") 'tempo-backward-mark))

  (setq hippie-expand-try-functions-list
        (cons 'try-expand-tempo-tag
              (remove 'try-expand-tempo-tag hippie-expand-try-functions-list)))

#+end_src

**** c && c++ snippets using tempo

sourced from https://www.lysator.liu.se/~davidk/elisp/tempo-examples.html

#+begin_src emacs-lisp

(require 'tempo)

;; This is a way to hook tempo into cc-mode

(defvar c-tempo-tags nil
  "Tempo tags for C mode")

(defvar c++-tempo-tags nil
  "Tempo tags for C++ mode")

;;; C-Mode Templates and C++-Mode Templates (uses C-Mode Templates also)
(add-hook 'c-mode-hook
          (lambda () (progn
                      ;;; Preprocessor Templates (appended to c-tempo-tags)

                       (tempo-define-template "c-include"
                                              '("#include <" r ".h>" > n
                                                )
                                              "#include"
                                              "Insert a #include <> statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-ifdef"
                                              '("#ifdef " (p "ifdef-clause: " clause) > n> p n
                                                "#else /* !(" (s clause) ") */" n> p n
                                                "#endif /* " (s clause)" */" n>
                                                )
                                              "#ifdef"
                                              "Insert a #ifdef #else #endif statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-ifndef"
                                              '("#ifndef " (p "ifndef-clause: " clause) > n 
                                                "#define " (s clause) n> p n
                                                "#endif /* " (s clause)" */" n>
                                                )
                                              "#ifndef"
                                              "Insert a #ifndef #define #endif statement"
                                              'c-tempo-tags)

                       ;;; C-Mode Templates

                       (tempo-define-template "c-if"
                                              '(> "if(" (p "if-clause: " clause) ")"  n> 
                                                  "{" > n> r n 
                                                  "} /* end of if(" (s clause) ") */" > n> 
                                                  )
                                              "if"
                                              "Insert a C if statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-else"
                                              '(> "else" n> 
                                                  "{" > n> r n 
                                                  "} /* end of else */" > n>
                                                  )
                                              "else"
                                              "Insert a C else statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-if-else"
                                              '(> "if(" (p "if-clause: " clause) ")"  n> 
                                                  "{" > n> r n 
                                                  "} /* end of if(" (s clause) ") */" > n>
                                                  > "else" n> 
                                                  "{" > n> r n 
                                                  "} /* end of if(" (s clause) ")else */" > n> 
                                                  )
                                              "ifelse"
                                              "Insert a C if else statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-while"
                                              '(> "while(" (p "while-clause: " clause) ")" >  n> 
                                                  "{" > n> r n 
                                                  "} /* end of while(" (s clause) ") */" > n>
                                                  )
                                              "while"
                                              "Insert a C while statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-for"
                                              '(> "for(" (p "for-clause: " clause) ")" >  n> 
                                                  "{" > n> r n 
                                                  "} /* end of for(" (s clause) ") */" > n>
                                                  )
                                              "for"
                                              "Insert a C for statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-for-i"
                                              '(> "for(" (p "variable: " var) " = 0; " (s var)
                                                  " < "(p "upper bound: " ub)"; " (s var) "++)" >  n> 
                                                  "{" > n> r n 
                                                  "} /* end of for(" (s var) " = 0; "
                                                  (s var) " < " (s ub) "; " (s var) "++) */" > n>
                                                  )
                                              "fori"
                                              "Insert a C for loop: for(x = 0; x < ..; x++)"
                                              'c-tempo-tags)

                       (tempo-define-template "c-for"
                                              '(> "for(" (p "for-clause: " clause) ")" >  n> 
                                                  "{" > n> r n 
                                                  "} /* end of for(" (s clause) ") */" > n>
                                                  )
                                              "for"
                                              "Insert a C for statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-main"
                                              '(> "main(int argc, char *argv[])" >  n> 
                                                  "{" > n> r n 
                                                  "} /* end of main() */" > n>
                                                  )
                                              "main"
                                              "Insert a C main statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-if-malloc"
                                              '(> "if((" (p "variable: " var) " = ("
                                                  (p "type: " type) " *) malloc(sizeof(" (s type) 
                                                  "))) == (" (s type) " *) NULL)" n> 
                                                  "{" > n> r n 
                                                  "} /* end of if((" (s var) " = (" (s type) 
                                                  " *) malloc...) == NULL) */" > n>
                                                  )
                                              "ifmalloc"
                                              "Insert a C if(malloc...) statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-switch"
                                              '(> "switch(" (p "switch-condition: " clause) ")" >  n> 
                                                  "{" > n 
                                                  "case " (p "first value: ") ":" > n> p n
                                                  "break;" > n> p n
                                                  "default:" > n> p n
                                                  "break;" > n
                                                  "} /* end of switch(" (s clause) ") */" > n>
                                                  )
                                              "switch"
                                              "Insert a C switch statement"
                                              'c-tempo-tags)

                       (tempo-define-template "c-case"
                                              '(n "case " (p "value: ") ":" > n> p n
                                                  "break;" > n> p
                                                  )
                                              "case"
                                              "Insert a C case statement"
                                              'c-tempo-tags)

                       (set-tempo)
                       (tempo-use-tag-list 'c-tempo-tags))))


;;;C++-Mode Templates

(add-hook 'c++-mode-hook
          (lambda () (progn 
                       (tempo-define-template "c++-class"
                                              '("class " (p "classname: " class) p n "{" n "public:" n>

                                                (s class) "();" 
                                                (indent-for-comment) "the default constructor" n>

                                                (s class) 
                                                "(const " (s class) "&rhs);"
                                                (indent-for-comment) "the copy constructor" n>

                                                (s class)
                                                "& operator=(const " (s class) "&rhs);"
                                                (indent-for-comment) "the assignment operator" n>

                                                n> "// the default address-of operators" n>
                                                "// "(s class)
                                                "* operator&()             { return this; };" n>
                                                "// const "(s class)
                                                "* operator&() const { return this; };" n


                                                n > "~" (s class) "();"
                                                (indent-for-comment) "the destructor" n n>
                                                p n
                                                "protected:" n> p n
                                                "private:" n> p n
                                                "};\t// end of class " (s class) n>
                                                )
                                              "class"
                                              "Insert a class skeleton"
                                              'c++-tempo-tags)
                       (set-tempo)
                       (tempo-use-tag-list 'c-tempo-tags)
                       (tempo-use-tag-list 'c++-tempo-tags))))

#+end_src

**** Emacs-lisp snippets using tempo

#+begin_src emacs-lisp

(defun define-my-elisp-tempo-tags ()
  (defvar elisp-tempo-tags nil)

  (tempo-define-template "defun"
                         '("defun " p " (" p ")" n> "\"" p "\"" n> r ")")
                         "defun"
                         "Insert a defun expression"
                         'elisp-tempo-tags)
  (tempo-define-template "defvar"
                         '("defvar " p  n> "\"" p "\")")
                         "defvar"
                         "Insert a defvar expression"
                         'elisp-tempo-tags)

  (tempo-define-template "lambda"
                         '("lambda (" p ")" n> "\"" p "\"" n> r ")")
                         "lambda"
                         "Insert a lamb expression"
                         'elisp-tempo-tags)

  (tempo-define-template "if"
                         '("if " p n> r ")")
                         "if"
                         "Insert an if expression"
                         'elisp-tempo-tags)

  (tempo-define-template "when"
                         '("when " p n> r ")")
                         "when"
                         "Insert an when expression"
                         'elisp-tempo-tags)

  (tempo-define-template "unless"
                         '("unless " p n> r ")")
                         "unless"
                         "Insert an unless expression"
                         'elisp-tempo-tags)

  (tempo-define-template "cond"
                         '("cond ((" p ") " r "))")
                         "cond"
                         "Insert a cond expression"
                         'elisp-tempo-tags))


(add-hook 'emacs-lisp-mode-hook (lambda () (progn (define-my-elisp-tempo-tags)
                                                  (set-tempo)
                                                  (setq tempo-match-finder "(\\([^\b]+\\)\\=")
                                                  (tempo-use-tag-list 'elisp-tempo-tags))))

(add-hook 'lisp-interaction-mode-hook (lambda () (progn (define-my-elisp-tempo-tags)
                                                        (set-tempo)
                                                        (setq tempo-match-finder "(\\([^\b]+\\)\\=")
                                                        (tempo-use-tag-list 'elisp-tempo-tags))))
#+end_src

**** org-mode snippets using tempo

#+begin_src emacs-lisp

(add-hook 'org-mode-hook (lambda () (progn 
;;; org-mode templates
                                      (defvar org-tempo-tags nil)

                                      (tempo-define-template "title"
                                                             '("TITLE: "> p)
                                                             "ti"
                                                             "Insert a document title"
                                                             'org-tempo-tags)

                                      (tempo-define-template "author"
                                                             '("AUTHOR: "> p)
                                                             "au"
                                                             "Insert a author name"
                                                             'org-tempo-tags)

                                      (tempo-define-template "src_block"
                                                             '("begin_src "> p n> p n> "#+end_src" n>)
                                                             "src"
                                                             "Insert a defun expression"
                                                             'org-tempo-tags)


                                      (set-tempo)
                                      (defvar html-tempo-tags nil)
                                      (tempo-use-tag-list 'org-tempo-tags)
                                      (setq tempo-match-finder "\\#\\+\\([^\b]+\\)\\="))))

#+end_src

**** ruby snippets using tempo

#+begin_src emacs-lisp

;;; ruby-mode templates

(add-hook 'ruby-mode-hook (lambda () (progn 
                                       (defvar ruby-tempo-tags nil)

                                       (tempo-define-template "ruby-class"
                                                              '("class " > p n> p n "end" >)
                                                              "cls"
                                                              "Insert a class"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-module"
                                                              '("module " > p n> p n "end" >)
                                                              "mod"
                                                              "Insert a class"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-def"
                                                              '("def " > p "(" p ")" n> p n "end" >)
                                                              "def"
                                                              "Insert a module"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-intialize"
                                                              '("def intialize(" p ")" > n> p n> "end" >)
                                                              "init"
                                                              "Insert a constructor"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-include"
                                                              '("include " > p >)
                                                              "incl"
                                                              "include a module"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-require"
                                                              '("require \"" > p "\"" >)
                                                              "req"
                                                              "require"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-if"
                                                              '("if " > p n> p n> "end" >)
                                                              "if"
                                                              "Insert an if clause"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-ifelse"
                                                              '("if " > p n >"else " n> p n> "end" >)
                                                              "ifel"
                                                              "Insert an if else clause"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-unless"
                                                              '("unless "> p n> p n> "end" >)
                                                              "unless"
                                                              "Insert a unless clause"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-until"
                                                              '("until " > p n> p n> "end" >)
                                                              "until"
                                                              "Insert an until loop"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-when"
                                                              '(> "when "> p n> p n> "end" >)
                                                              "when"
                                                              "Insert a when clause"
                                                              'ruby-tempo-tags)

                                       (tempo-define-template "ruby-while"
                                                              '("while "> p n> p n> "end" >)
                                                              "while"
                                                              "Insert a while loop"
                                                              'ruby-tempo-tags)

                                       (set-tempo)
                                       (tempo-use-tag-list 'ruby-tempo-tags))))

#+end_src

**** python snippets using tempo

#+begin_src emacs-lisp

(add-hook 'python-mode-hook
          (lambda () (progn

;;; python-mode templates
                       (defvar python-tempo-tags nil)

                       (tempo-define-template "python-class"
                                              '("class " > p ":"n>)
                                              "cls"
                                              "Insert a class"
                                              'python-tempo-tags)

                       (tempo-define-template "python-def"
                                              '("def " > p "(" p "):" n> p n>)
                                              "def"
                                              "define a function"
                                              'python-tempo-tags)

                       (tempo-define-template "import"
                                              '("import " p >)
                                              "imp"
                                              "python import"
                                              'python-tempo-tags)


                       (tempo-define-template "python-include"
                                              '("from " > p " import " p>)
                                              "from"
                                              "from tag"
                                              'python-tempo-tags)

                       (tempo-define-template "python-if"
                                              '("if " > p ":"n> p >)
                                              "if"
                                              "Insert an if clause"
                                              'python-tempo-tags)

                       (tempo-define-template "python-ifelse"
                                              '("if " > p ":"n> p "else:" n> p >)
                                              "ife"
                                              "Insert an if else clause"
                                              'python-tempo-tags)

                       (set-tempo)
                       (tempo-use-tag-list 'python-tempo-tags))))

#+end_src

**** html snippets using tempo

#+begin_src emacs-lisp

  ;;; html tempo templates
  (add-hook 'html-mode-hook (lambda () (progn 
                                         (defvar html-tempo-tags nil)

                                         (defmacro html-tempo-paired-tag-single-line (var)
                                           (list 'tempo-define-template var
                                                 (list 'quote (list var "> " '> 'p (concat " </" var ">") '>))
                                                 var
                                                 (concat "insert html " var " tag")
                                                 (list 'quote 'html-tempo-tags)))

                                         (seq-do (lambda (x)
                                                   "expand macro"
                                                   (eval (list 'html-tempo-paired-tag-single-line x)))
                                                 '("a" "b" "bdi" "bdo"
                                                   "button" "caption" "cite" "data"
                                                   "del" "dfn" "em" "figcaption"
                                                   "h1" "h2" "h3" "h4"
                                                   "h5" "h6" "i" "iframe"
                                                   "kbd" "li" "label" "legend"
                                                   "mark" "meter" "object" "option"
                                                   "p" "progress" "q" "summary"
                                                   "s" "samp" "small" "span"
                                                   "strong" "sub" "summary" "sup"
                                                   "th" "td" "title" "time"))

                                         (defmacro html-tempo-paired-tag-multi-line (var)
                                           (list 'tempo-define-template var
                                                 (list 'quote (list var ">" 'n> 'p 'n> (concat "</" var ">") '>))
                                                 var
                                                 (concat "insert html " var " tag")
                                                 (list 'quote 'html-tempo-tags)))

                                         (seq-do (lambda (x)
                                                   "expand macro"
                                                   (eval (list 'html-tempo-paired-tag-multi-line x)))
                                                 '("address" "article" "aside" "audio"
                                                   "body" "blockquote" "colgroup" "canvas"
                                                   "code" "datalist" "dl" "details"
                                                   "dialogue" "div" "fieldset" "figure"
                                                   "footer" "form" "head" "header"
                                                   "map" "main" "noscript" "nav"
                                                   "ol" "optgroup" "pre" "script"
                                                   "section" "select" "style" "svg"
                                                   "table" "thead" "tbody" "tfoot"
                                                   "tr" "template" "textarea" "ul"
                                                   "video"))


                                         (tempo-define-template "image-item"
                                                                '("img src=\"" > p "\" alt=\"" p ">">)
                                                                "img"
                                                                "insert html image tag"
                                                                'html-tempo-tags)

                                         (tempo-define-template "abbr"
                                                                '("abbr title=\"" > p "\">" p "</abbr>">)
                                                                "abbr"
                                                                "insert html abbr tag"
                                                                'html-tempo-tags)

                                         (tempo-define-template "html"
                                                                '("!DOCTYPE html>" n> "<html>" n>"<head>" n>
                                                                  "<title> " > p " </title>" p n>
                                                                  "</head>" n>
                                                                  "<body>" n>  p
                                                                  "\n</body>" > n "</html>" n>)
                                                                "html"
                                                                "insert a html template"
                                                                'html-tempo-tags)

                                         (set-tempo)
                                         (tempo-use-tag-list 'html-tempo-tags)
                                         (setq tempo-match-finder "\\(?:<!?\\)\\([^\b]+\\)\\=")
                                         )))

#+end_src


* create launchers for some tui apps if they exist

#+begin_src emacs-lisp

  (defun rtfm-create-terminal-function (tuiapp)
    "Create a terminal function for the given BINARY."
    (let ((function-name (intern (format "%s-term-open" tuiapp))))
      (when (executable-find tuiapp)
        (eval `(defun ,function-name ()
                 ,(format "Open %s using ansi-term." tuiapp)
                 (interactive)
                 (ansi-term ,tuiapp))
              ;; to be added if if is used instead of when (message "Warning: '%s' tui app not found." tuiapp)
              ))))

  (defvar rtfm-tui-apps '("toipe" "nnn" "nmtui" "htop" "nvim" "lynx" "gtypist" "lazygit")
    "List of tui apps to create functions for.")

  (add-hook 'after-init-hook
            (lambda () (dolist (binary rtfm-tui-apps)
                         (rtfm-create-terminal-function binary))))

#+end_src

  
* load-theme

#+begin_src emacs-lisp

  (defconst theme-directory (expand-file-name "themes" user-emacs-directory))

  (unless (file-directory-p theme-directory)
    (make-directory theme-directory))

  (add-to-list 'custom-theme-load-path
               (expand-file-name "themes" user-emacs-directory))


  (let ((basedir theme-directory))
    (dolist (f (directory-files basedir))
      (if (and (not (or (equal f ".") (equal f "..")))
               (file-directory-p (concat basedir f)))
          (add-to-list 'custom-theme-load-path (concat basedir f)))))


  (add-hook 'after-init-time-hook
            (progn
              (load-theme 'rtfm-noone-dark t)))

#+end_src


* load custom faces

#+begin_src emacs-lisp

  (add-hook 'after-init-hook
            (lambda ()
              (let ((dafile (expand-file-name "custom_faces.el" user-emacs-directory)))
                (when (file-exists-p dafile) (load-file dafile)))))

  (when EMACS27+
    (add-hook 'server-after-make-frame-hook
              (lambda ()
                (let ((dafile (expand-file-name "custom_faces.el" user-emacs-directory)))
                  (when (file-exists-p dafile) (load-file dafile))))))

#+end_src
  

* ending
#+begin_src emacs-lisp
  ;;; rtfm.el ends here
#+end_src

